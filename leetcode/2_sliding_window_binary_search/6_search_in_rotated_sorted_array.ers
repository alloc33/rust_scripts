#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! ```

/*
There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly left rotated at an unknown index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be left rotated by 3 indices and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.
*/

pub fn search(nums: Vec<i32>, target: i32) -> i32 {
	let (mut left, mut right) = (0, nums.len() - 1);

	while left <= right {
		let mid = left + (right - left) / 2;

		// Found target
		if nums[mid] == target {
			return mid as i32;
		}

		// Left half is sorted
		if nums[left] <= nums[mid] {
			if nums[left] <= target && target < nums[mid] {
				right = mid - 1;
			} else {
				left = mid + 1;
			}
		}
		// Right half is sorted
		else {
			if nums[mid] < target && target <= nums[right] {
				left = mid + 1;
			} else {
				right = mid - 1;
			}
		}
	}

	-1
}

fn main() {
	assert_eq!(search(vec![4, 5, 6, 7, 0, 1, 2], 0), 4);
	assert_eq!(search(vec![4, 5, 6, 7, 0, 1, 2], 3), -1);
	assert_eq!(search(vec![1], 0), -1);
	assert_eq!(search(vec![1], 1), 0);
	assert_eq!(search(vec![3, 1], 1), 1);

	println!("All tests passed!");
}

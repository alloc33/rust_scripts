#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! ```

use std::collections::VecDeque;

// You are given an m x n grid where each cell can have one of three values:

//     0 representing an empty cell,
//     1 representing a fresh orange, or
//     2 representing a rotten orange.

// Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

// Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.

// Constraints:
//     m == grid.length
//     n == grid[i].length
//     1 <= m, n <= 10
//     grid[i][j] is 0, 1, or 2.

pub fn oranges_rotting(mut grid: Vec<Vec<i32>>) -> i32 {
    let m = grid.len();
    let n = grid[0].len();

    // 4 directions: up, down, left, right
    let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)];

    // BFS queue: stores (row, col)
    let mut queue = VecDeque::new();

    // Count fresh oranges and find all initially rotten oranges
    let mut fresh_count = 0;
    for i in 0..m {
        for j in 0..n {
            if grid[i][j] == 2 {
                // Add all rotten oranges to queue (multi-source BFS)
                queue.push_back((i, j));
            } else if grid[i][j] == 1 {
                // Count fresh oranges
                fresh_count += 1;
            }
        }
    }

    // Edge case: no fresh oranges at all
    if fresh_count == 0 {
        return 0;
    }

    // Edge case: no rotten oranges but have fresh ones
    if queue.is_empty() {
        return -1;
    }

    // Track minutes elapsed
    let mut minutes = 0;

    // BFS: process level by level (each level = 1 minute)
    while !queue.is_empty() {
        // Process all oranges that rot at current minute
        let level_size = queue.len();

        for _ in 0..level_size {
            let (row, col) = queue.pop_front().unwrap();

            // Try all 4 directions
            for &(dr, dc) in &directions {
                let new_row = row as i32 + dr;
                let new_col = col as i32 + dc;

                // Check bounds
                if new_row < 0 || new_row >= m as i32 || new_col < 0 || new_col >= n as i32 {
                    continue;
                }

                let new_row = new_row as usize;
                let new_col = new_col as usize;

                // Only rot fresh oranges (value 1)
                if grid[new_row][new_col] == 1 {
                    // Mark as rotten
                    grid[new_row][new_col] = 2;

                    // Decrease fresh orange count
                    fresh_count -= 1;

                    // Add to queue for next minute's spread
                    queue.push_back((new_row, new_col));
                }
            }
        }

        // Increment minutes after processing current level
        // Only if there are more oranges to rot
        if !queue.is_empty() {
            minutes += 1;
        }
    }

    // Check if all fresh oranges became rotten
    if fresh_count == 0 {
        minutes
    } else {
        -1 // Some fresh oranges unreachable
    }
}

fn main() {
    assert_eq!(oranges_rotting(vec![vec![2, 1, 1], vec![1, 1, 0], vec![0, 1, 1]]), 4);
    assert_eq!(oranges_rotting(vec![vec![2, 1, 1], vec![0, 1, 1], vec![1, 0, 1]]), -1);
    assert_eq!(oranges_rotting(vec![vec![0, 2]]), 0);
    assert_eq!(oranges_rotting(vec![vec![2, 2], vec![1, 1], vec![0, 0], vec![2, 1]]), 1);
    assert_eq!(oranges_rotting(vec![vec![0]]), 0);
    assert_eq!(oranges_rotting(vec![vec![1]]), -1);

    println!("All tests passed!");
}

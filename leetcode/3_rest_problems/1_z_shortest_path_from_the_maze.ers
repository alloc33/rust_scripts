#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! ```

use std::collections::HashSet;
use std::collections::VecDeque;

fn shortest_path(maze: &[Vec<char>], start: (usize, usize), end: (usize, usize)) -> i32 {
    // Get maze dimensions for boundary checking
    let rows = maze.len();
    let cols = maze[0].len();
    // QUEUE: Stores positions to visit next, in order (FIFO = First In First Out)
    // BFS uses a queue to explore level-by-level (distance 0, then 1, then 2, etc.)
    let mut queue = VecDeque::new();
    // VISITED SET: Tracks which positions we've already seen
    // Prevents revisiting the same cell and getting stuck in loops
    let mut visited = HashSet::new();
    // Add starting position to queue with distance 0
    // Format: (row, column, distance_from_start)
    queue.push_back((start.0, start.1, 0));
    // Mark start as visited immediately to avoid revisiting it
    visited.insert((start.0, start.1));
    // DIRECTIONS: All 4 possible moves (right, down, left, up)
    // (row_change, column_change)
    let directions = [
        (0, 1),  // right: same row, +1 column
        (1, 0),  // down: +1 row, same column
        (0, -1), // left: same row, -1 column
        (-1, 0), // up: -1 row, same column
    ];
    // BFS MAIN LOOP: Process each position in the queue
    // pop_front() gets the OLDEST item (FIFO behavior)
    // This ensures we explore distance 0 positions, then distance 1, then distance 2, etc.
    while let Some((row, col, dist)) = queue.pop_front() {
        // SUCCESS: Found the end position
        // Return the distance it took to get here
        if (row, col) == end {
            return dist;
        }
        // EXPLORE NEIGHBORS: Try moving in all 4 directions
        for (dr, dc) in directions.iter() {
            // Calculate new position
            // Use i32 to handle negative numbers (going left or up)
            let new_row = row as i32 + dr;
            let new_col = col as i32 + dc;
            // BOUNDARY CHECK: Make sure new position is inside the maze
            if new_row >= 0 && new_row < rows as i32 && new_col >= 0 && new_col < cols as i32 {
                // Convert back to usize for array indexing
                let nr = new_row as usize;
                let nc = new_col as usize;
                // VALIDITY CHECK: Can we actually move to this cell?
                // 1. maze[nr][nc] != '#' → not a wall (assume '#' = wall, '.' = open)
                // 2. !visited.contains() → haven't been here before
                if maze[nr][nc] != '#' && !visited.contains(&(nr, nc)) {
                    // Mark as visited NOW (before adding to queue)
                    // This prevents adding the same cell multiple times
                    visited.insert((nr, nc));
                    // Add to BACK of queue with distance + 1
                    // This cell is one step further from start than current cell
                    queue.push_back((nr, nc, dist + 1));
                }
            }
        }
    }
    // FAILURE: Queue is empty and we never found the end
    // This means there's no valid path from start to end
    return -1;
}

fn main() {
    // Test 1: Simple straight path
    #[rustfmt::skip]
    let maze1 = vec![
        vec!['.', '.', '.'],
        vec!['.', '.', '.'],
        vec!['.', '.', '.']
    ];
    assert_eq!(shortest_path(&maze1, (0, 0), (2, 2)), 4);

    // Test 2: Path with walls
    #[rustfmt::skip]
    let maze2 = vec![
        vec!['.', '#', '.'],
        vec!['.', '#', '.'],
        vec!['.', '.', '.']
    ];
    assert_eq!(shortest_path(&maze2, (0, 0), (0, 2)), 6);

    // Test 3: No path (blocked)
    #[rustfmt::skip]
    let maze3 = vec![
        vec!['.', '#', '.'],
        vec!['.', '#', '.'],
        vec!['.', '#', '.']
    ];
    assert_eq!(shortest_path(&maze3, (0, 0), (0, 2)), -1);

    // Test 4: Start equals end
    #[rustfmt::skip]
    let maze4 = vec![
        vec!['.', '.', '.'],
        vec!['.', '.', '.']
    ];
    assert_eq!(shortest_path(&maze4, (0, 0), (0, 0)), 0);

    // Test 5: Longer maze
    #[rustfmt::skip]
    let maze5 = vec![
        vec!['.', '.', '.', '#', '.'],
        vec!['#', '#', '.', '#', '.'],
        vec!['.', '.', '.', '.', '.'],
        vec!['.', '#', '#', '#', '.'],
        vec!['.', '.', '.', '.', '.']
    ];
    assert_eq!(shortest_path(&maze5, (0, 0), (4, 4)), 8);

    println!("All tests passed!");
}

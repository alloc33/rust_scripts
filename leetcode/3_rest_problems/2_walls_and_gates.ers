#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! ```

// You have a grid representing a floor plan with rooms, walls, and gates.
// The grid is an m x n matrix where each cell contains one of three values:

//     -1 → a wall or obstacle that cannot be passed through
//     0 → a gate
//     2147483647 (which is 2^31 - 1, also referred to as INF) → an empty room

// You are tasked to fill each empty room with its shortest distance to the nearest gate.

//     Distance is measured as the minimum number of steps needed to reach a gate.
//     Movement is only allowed horizontally or vertically (not diagonally).
//     If an empty room cannot reach any gate (blocked by walls), it should remain INF.

// Input:

// [[2147483647,-1,0,2147483647],
// [2147483647,2147483647,2147483647,-1],
// [2147483647,-1,2147483647,-1],
// [0,-1,2147483647,2147483647]]

// Output:

// [[3,-1,0,1],
// [2,2,1,-1],
// [1,-1,2,-1],
// [0,-1,3,4]]


// Explanation: Each empty room is filled with its shortest distance to the nearest gate.

// Constraints:

//     m == rooms.length
//     n == rooms[i].length
//     1 <= m, n <= 250
//     rooms[i][j] is -1, 0, or 2^31 - 1

// Note: The algorithm modifies the input grid in-place

// Movement is only allowed horizontally or vertically

// Unreachable rooms remain as INF

use std::collections::VecDeque;

pub fn walls_and_gates(rooms: &mut Vec<Vec<i32>>) {
	if rooms.is_empty() || rooms[0].is_empty() {
		return;
	}

	let m = rooms.len();
	let n = rooms[0].len();
	const INF: i32 = 2147483647;

	// 4 directions: up, down, left, right (no diagonals)
	let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)];

	// BFS queue: stores (row, col)
	let mut queue = VecDeque::new();

	// Multi-source BFS: Add ALL gates to queue initially
	// This allows us to explore from all gates simultaneously
	for i in 0..m {
		for j in 0..n {
			if rooms[i][j] == 0 {
				queue.push_back((i, j));
			}
		}
	}

	// BFS from all gates at once
	while let Some((row, col)) = queue.pop_front() {
		// Current distance from a gate
		let current_distance = rooms[row][col];

		// Try all 4 directions
		for &(dr, dc) in &directions {
			let new_row = row as i32 + dr;
			let new_col = col as i32 + dc;

			// Check bounds
			if new_row < 0 || new_row >= m as i32 || new_col < 0 || new_col >= n as i32 {
				continue;
			}

			let new_row = new_row as usize;
			let new_col = new_col as usize;

			// Only process empty rooms (INF)
			// Skip walls (-1) and already visited rooms (distance < INF)
			if rooms[new_row][new_col] != INF {
				continue;
			}

			// Update distance: current distance + 1 step
			rooms[new_row][new_col] = current_distance + 1;

			// Add this room to queue to explore its neighbors
			queue.push_back((new_row, new_col));
		}
	}
}

fn main() {
	const INF: i32 = 2147483647;

	let mut rooms1 = vec![
		vec![INF, -1, 0, INF],
		vec![INF, INF, INF, -1],
		vec![INF, -1, INF, -1],
		vec![0, -1, INF, INF],
	];
	walls_and_gates(&mut rooms1);
	assert_eq!(
		rooms1,
		vec![vec![3, -1, 0, 1], vec![2, 2, 1, -1], vec![1, -1, 2, -1], vec![0, -1, 3, 4]]
	);

	let mut rooms2 = vec![vec![-1]];
	walls_and_gates(&mut rooms2);
	assert_eq!(rooms2, vec![vec![-1]]);

	let mut rooms3 = vec![vec![0]];
	walls_and_gates(&mut rooms3);
	assert_eq!(rooms3, vec![vec![0]]);

	let mut rooms4 = vec![vec![INF]];
	walls_and_gates(&mut rooms4);
	assert_eq!(rooms4, vec![vec![INF]]);

	println!("All tests passed!");
}

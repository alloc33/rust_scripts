#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! rand = "0.8"
//! ```

// Implement a collection such that you can insert a key/value pair in O(1), delete some value (by
// giving the key) in O(1), and ask for a pseudo-random value from the collection in O(1). You may
// use a library to generate a random number.

use rand::Rng;
use std::collections::HashMap;

struct RandomMap<K, V>
where
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    // key -> (value, index in keys vec)
    map: HashMap<K, (V, usize)>,

    // index -> key (for random access)
    keys: Vec<K>,
}

impl<K, V> RandomMap<K, V>
where
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    fn new() -> Self {
        RandomMap { map: HashMap::new(), keys: Vec::new() }
    }

    fn insert(&mut self, key: K, value: V) -> bool {
        // Check if key already exists
        if self.map.contains_key(&key) {
            return false; // Key already present
        }

        // Add key to end of keys vec
        self.keys.push(key.clone());

        // Store key -> (value, index) mapping
        let index = self.keys.len() - 1;
        self.map.insert(key, (value, index));

        true
    }

    fn remove(&mut self, key: &K) -> bool {
        // Check if key exists
        if let Some((_, index)) = self.map.get(key) {
            let index = *index;

            // Get last key in vec
            let last_key = self.keys.last().unwrap().clone();

            // Swap: move last key to position of key to remove
            self.keys[index] = last_key.clone();

            // Update the moved key's index in map
            if let Some((value, _)) = self.map.get(&last_key) {
                let value = value.clone();
                self.map.insert(last_key, (value, index));
            }

            // Remove last key from vec
            self.keys.pop();

            // Remove from map
            self.map.remove(key);

            true
        } else {
            false // Key not present
        }
    }

    fn get_random(&self) -> &V {
        // Generate random index
        let random_index = rand::thread_rng().gen_range(0..self.keys.len());

        // Get key at random index
        let random_key = &self.keys[random_index];

        // Look up value for that key
        let (value, _) = self.map.get(random_key).unwrap();

        value
    }
}

fn main() {
    let mut rm = RandomMap::new();

    // Test insert
    assert_eq!(rm.insert(1, "one"), true);
    assert_eq!(rm.insert(2, "two"), true);
    assert_eq!(rm.insert(3, "three"), true);
    assert_eq!(rm.insert(1, "duplicate"), false); // Already exists

    // Test get_random returns valid values
    for _ in 0..10 {
        let val = rm.get_random();
        assert!(["one", "two", "three"].contains(val));
    }

    // Test remove
    assert_eq!(rm.remove(&2), true);
    assert_eq!(rm.remove(&2), false); // Already removed
    assert_eq!(rm.remove(&99), false); // Never existed

    // After removing 2, only 1 and 3 should remain
    for _ in 0..10 {
        let val = rm.get_random();
        assert!(["one", "three"].contains(val));
    }

    // Remove remaining
    assert_eq!(rm.remove(&1), true);
    assert_eq!(rm.remove(&3), true);

    // Test with strings
    let mut str_map = RandomMap::new();
    str_map.insert("key1".to_string(), 100);
    str_map.insert("key2".to_string(), 200);
    str_map.insert("key3".to_string(), 300);

    for _ in 0..10 {
        let val = str_map.get_random();
        assert!([100, 200, 300].contains(val));
    }

    println!("All tests passed!");
}

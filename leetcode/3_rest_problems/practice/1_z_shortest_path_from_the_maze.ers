#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! ```

// You are given an `m x n` maze represented as a 2D character array where:
// - `'.'` represents an empty cell (walkable)
// - `'#'` represents a wall (blocked)

// You are also given two positions:
// - `start = [row_start, col_start]` - the starting position
// - `end = [row_end, col_end]` - the destination position

// Return the length of the shortest path from `start` to `end`. If no such path exists, return `-1`.

// You can move in four directions: up, down, left, and right. You cannot move diagonally or move outside the maze boundaries.

// ## Constraints

// - `m == maze.length`
// - `n == maze[i].length`
// - `1 <= m, n <= 100`
// - `maze[i][j]` is either `'.'` or `'#'`
// - `0 <= row_start, row_end < m`
// - `0 <= col_start, col_end < n`

fn shortest_path(maze: &[Vec<char>], start: (usize, usize), end: (usize, usize)) -> i32 {
    todo!()
}

fn main() {
    // Test 1: Simple straight path
    #[rustfmt::skip]
    let maze1 = vec![
        vec!['.', '.', '.'],
        vec!['.', '.', '.'],
        vec!['.', '.', '.']
    ];
    assert_eq!(shortest_path(&maze1, (0, 0), (2, 2)), 4);

    // Test 2: Path with walls
    #[rustfmt::skip]
    let maze2 = vec![
        vec!['.', '#', '.'],
        vec!['.', '#', '.'],
        vec!['.', '.', '.']
    ];
    assert_eq!(shortest_path(&maze2, (0, 0), (0, 2)), 6);

    // Test 3: No path (blocked)
    #[rustfmt::skip]
    let maze3 = vec![
        vec!['.', '#', '.'],
        vec!['.', '#', '.'],
        vec!['.', '#', '.']
    ];
    assert_eq!(shortest_path(&maze3, (0, 0), (0, 2)), -1);

    // Test 4: Start equals end
    #[rustfmt::skip]
    let maze4 = vec![
        vec!['.', '.', '.'],
        vec!['.', '.', '.']
    ];
    assert_eq!(shortest_path(&maze4, (0, 0), (0, 0)), 0);

    // Test 5: Longer maze
    #[rustfmt::skip]
    let maze5 = vec![
        vec!['.', '.', '.', '#', '.'],
        vec!['#', '#', '.', '#', '.'],
        vec!['.', '.', '.', '.', '.'],
        vec!['.', '#', '#', '#', '.'],
        vec!['.', '.', '.', '.', '.']
    ];
    assert_eq!(shortest_path(&maze5, (0, 0), (4, 4)), 8);

    println!("All tests passed!");
}

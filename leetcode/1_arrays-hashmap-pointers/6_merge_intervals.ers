#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! ```

// Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

pub fn merge(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
    let mut intervals = intervals;

    // Sort intervals by start time
    // This allows us to process them in order and check only adjacent intervals
    intervals.sort_unstable_by_key(|interval| interval[0]);

    // Result vector to store merged intervals
    let mut merged: Vec<Vec<i32>> = vec![];

    for interval in intervals {
        // If merged is empty OR current interval doesn't overlap with last merged interval
        // Add it as a new interval
        if merged.is_empty() || merged.last().unwrap()[1] < interval[0] {
            merged.push(interval);
        } else {
            // Current interval overlaps with last merged interval
            // Extend the end of last interval to cover both
            let last_idx = merged.len() - 1;
            merged[last_idx][1] = merged[last_idx][1].max(interval[1]);
        }
    }

    merged
}

fn main() {
    assert_eq!(
        merge(vec![vec![1, 3], vec![2, 6], vec![8, 10], vec![15, 18]]),
        vec![vec![1, 6], vec![8, 10], vec![15, 18]]
    );

    assert_eq!(merge(vec![vec![1, 4], vec![4, 5]]), vec![vec![1, 5]]);

    assert_eq!(merge(vec![vec![1, 4], vec![0, 4]]), vec![vec![0, 4]]);

    assert_eq!(merge(vec![vec![1, 4]]), vec![vec![1, 4]]);

    println!("All tests passed!");
}
